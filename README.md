Implementing an HPN Converter in F#
===================================
By: Ethan Condon & Bryan Prather-Huff
-------------------------------------
### Summary
This project implements the HPN converter we were assigned in HW3 using F#, providing the same functionality as the Agda binary we submitted. _Please note we both submitted course feedback._
***

### Project Folder Organization
~~~bash
project/
├── HPN-Fsharp-PLC/ 		# Project Solution (VS2015)
├── Presentation/			# Presentation
├── Proposal/				# Project Proposal
├── final/
|	├── ReleaseGradable/		# Contains Files to Grade
│  	|	├── Source/					# The F# source
│  	|	└── Executable/				# Pre-compiled
|	└── report.md*pdf				# This file
~~~
***

### Code Walk-Through/Compilation
Because of reliance on .NET and other complex dependencies it is in our best interest to provide you with a more simplified way to analyze and grade our code.  

We have provided a directory which contains exclusivly the source code we have written for our project and a pre-compiled executable which bundles as many dependencies as licensing allows (Mono and .Net don't like to be bundled into *nix executables).

We have also provided the Visual Studio 2015 Solution for our project. If you have access to VS2015 or Xamarin Studio, you can probably launch our solution and have the IDE gather and manage dependencies. We don't want to rely on the IDE playing nicely with you for our grade, so we have offered other methods to check our project than having you self-compile our project.

#### Source Guide
~~~bash
Source/
├── HPNtypes.fs 				# The parsed types derived from the Gratr grammar
├── HPNparser.fs				# The parser and functions to run the parsed types
└── HPNConverterMain.fs			# Main program, user interaction, and error handling
~~~
The project attempts to emulate the structure of the Gratr program we wrote for HW3. The parser is rooted in `HPNparser.parseHPNString` and the rest of the parser stems from there. The `HPNtypes` file holds the types which were generated by Gratr for us in HW3. We had to manually define these in F#. The processing commands to pay attention to are `HPNparser.runToHPN` and `HPNparser.runToDec`.

##### Execution
The binary to run is called `HPNConverter.exe` in the `ReleaseGradable/Executable` directory. All the required external dependancies to run the project under Mono or on Windows PC are included in the folder. To run using *nix, first install [Mono] (http://www.mono-project.com/docs/getting-started/install/linux/) and then use the executable by running `mono` and then the name of the executable followed by arguments. The exectuable can be used in a similar way to the Agda binary. Run `HPNConverter.exe {testfile} {showParsed?}` to run the converter. The showParsed aregument will be triggered by any character placed in the second arg position.
#### Example Execution
~~~bash
Bryans-MacBook-Pro:Executable bryan$ mono HPNConverter.exe test2.hpn show
Running Program
0 base 10
1 base 10
32 base 10
76 base 10
11 base 10
15 base 10
38 base 10


Dispalying Parsed
0 base 3
[ 0 ] base 7
[ [ [ [ 0 ] ] ] + [ 0 ] ] base 2
[ [ [ 0 ] ] ] + [ [ [ 0 ] ] ] + [ [ 0 ] + [ 0 ] ] + [ [ 0 ] + [ 0 ] ] + [ [ 0 ] ] + [ 0 ] base 3
[ [ [ 0 ] ] + [ 0 ] ] + [ [ 0 ] ] + [ 0 ] base 2
[ [ [ 0 ] ] + [ 0 ] ] + [ [ [ 0 ] ] ] + [ [ 0 ] ] + [ 0 ] base 2
[ [ 0 ] + [ 0 ] ] + [ [ 0 ] ] + [ [ 0 ] ] + [ 0 ] + [ 0 ] + [ 0 ] base 5


Press Any Key To Exit...
~~~

#### Test Cases
We included `test1.hpn` and `test2.hpn` in the `ReleaseGradable/Executable` directory to make testing easier. `test2.hpn` runs fine, but the toHPN function which is required for `test1.hpn` is still not fully implemented. It will run, but return the wrong HPN numbers. Parsing is still fine though. The output of our program is ideally identical to the output of `main` in HW3.
***

### Justification
We achived almost everything we set out to do. The only part that we didn't end up completing is the `HPNparser.runtoHPN` function, which we were time constrained by (lots of irons in the fire, and not enough time to focus on completing the function). The main issue we ran into with it was correctly doing type converisions between float and int to make an integer log function. Other than that we met all of our other requirments. The program acts almost idetically to the HW3 binary. Our code uses minimal elements of the imparitive paradigm, and instead relies on almost exclusivly functional control structures (tail-recursion, discriminating unions, etc). Our code is short by many standards (170 lines), but still shows generous effort put into the project.
***

### Future Directions
As with many acedemic projects, the interface to the program could be cleaned up a bit (add help flag and more informative help message). The main thing to be done with the project is completing the `runtoHPN function` so it build the correct HPN number.

